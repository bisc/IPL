grammar org.xtext.example.ipl.IPL with org.eclipse.xtext.common.Terminals

generate iPL "http://www.xtext.org/example/ipl/IPL"

import "http://aadl.info/AADL/2.0" as aadl2
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

IPLSpec:
	(imports += Import ';')*
	(decls += Declaration ';')*
	(formulas += Formula ';')*
;

Import:
	'import' importedNamespace=WQCREF
;

Declaration:
	TypedDecl | FunDecl
;

ViewDecl:
	'use' 'view' ref=[aadl2::ComponentImplementation | CIREF] 'as' name=ID 
;

ModelDecl:
	'use' 'model' name=ID ('(' (params+=ID)? (',' params+=ID)* ')')?
;

BaseType:
	{TypeInt} 'int' | {TypeReal} 'real' | {TypeBool} 'bool' | {TypeElem} 'elem' //| 'string'
;

Type:
	BaseType | {TypeSet} '{' elem=BaseType '}' | {TypeLst} '<<' elem=BaseType '>>'
;

TypedDecl:
	VarDecl | STVarDecl | SortDecl | ViewDecl | ModelDecl
;

VarDecl:
	'var' name=ID ':' type = Type
;

STVarDecl:
	'stvar' name=ID ':' type = Type
;

WQCREF: // for imports
	ID ('.' ID)* '.*'?
;

QCREF: // not used
	ID ('::' ID)*;

CIREF: // for subcomponents?
	ID ('.' ID)?
;

ElemDecl:
	'elem' ref=[aadl2::ComponentImplementation | CIREF]
;

SortDecl:
	'set' name=ID ':' ref=[aadl2::ComponentClassifier | CIREF] // used to be ComponentImplementation
;

FunDecl:
	(RFunDecl | MFunDecl | BFunDecl)
;

RFunDecl:
	'vrfun' name=ID '(' (paramTypes += Type)? (',' paramTypes += Type)* ')' IMP retType = Type
;

MFunDecl:
	'mfun' name=ID '(' (paramTypes += Type)? (',' paramTypes += Type)* ')' IMP retType = Type
;

BFunDecl:
	'bfun' name=ID '(' (paramTypes += Type)? (',' paramTypes += Type)* ')' IMP retType = Type
;

Bool:
	value=('true' | 'false')
;


Real returns ecore::EDouble:
	INT '.' INT (('e' | 'E') INT)?
;

Set:
	{Set} '{' (members += Expression)? (',' members += Expression)* '}'
;

Lst:
	{Lst} '<<' (members += Expression)? (',' members += Expression)* '>>'
;

Const:
	Set | Lst | ({Int} value=INT) | ({Real} value=Real ) | Bool //| {EString} STRING
;

Fun:
	name=[FunDecl] '(' (args += Term)? (',' args += Term)* ')'
;

// EXPRESSIONS

Expression:
	Addition;

Addition returns Expression:
	Multiplication (({ExprOperation.left=current} op=('+' | '-')) right=Multiplication)*
;

Multiplication returns Expression:
	PropertyExpression (({ExprOperation.left=current} op=('*' | '/')) right=PropertyExpression)*
;

PropertyExpression returns Expression:
	//elem=Property '::' member=Ident
	PrimaryExpression (({PropertyExpression.left=current} '::') right=Prop)*
;

Prop returns Prop:
	{Prop} id=ID
;

PrimaryExpression returns Expression:
	'(' Expression ')' |
	Const |
	Fun |
	{ID} id=ID | 
	ModelExpr
;

// TERMS

Term returns TermFormula: 
	'(' TermFormula ')' | (=> Expression)
;

TermFormula returns TermFormula:
		Term ({TermOperation.left=current} op=(LT | LTE | GT | GTE | EQ | NE) right=Term)*
;

// ATOMS

QAtom:
	op=(FORALL | EXISTS) var=ID ':' set=PrimaryExpression '|' exp=Formula 
;

Formula:
	NegFormula ({FormulaOperation.left=current} op=(AND | OR | IMP) right=NegFormula)* | (-> QAtom)
;

NegFormula returns Formula:
	{Negation} NOT child=NegFormula | FormulaBase
;

FormulaBase returns Formula:
	(=> TermFormula) | '(' Formula ')' | TAtom | ModelExpr
;

// BEHAVIORAL MODEL 

ModelExpr returns ModelExpr:
	expr=PrismExpr params=ModelParamExpr 
;

ModelParamExpr: 
	'{|' vals+=TermFormula (',' vals+=TermFormula)* '|}' |
		 {ModelParamExpr} '{|' '|}' 
;

//-----------------------------------------------------------------------------
// PCTL-specific syntax

			
PrismExpr:
	 (ProbQuery | RewardQuery) 
;

PrismComp:
	EQ | LT | GT
;

PrismValue:
	Expression | {QM} '?' 
;

PrismMinMax: 
	val='min' | val='max'
;

ProbQuery:
	'P' (minmax=PrismMinMax)? comp=PrismComp value=PrismValue '[' expr=Formula ']' 
;

RewardQuery:
	'R' ('{' rewardName=QUOTED_STRING /*rewardName=ID*/ '}')? (minmax=PrismMinMax)?  comp=PrismComp value=PrismValue '[' expr=Formula ']'
;



//-----------------------------------------------------------------------------
// LTL-specific syntax

TAtom: //TODO: make until binary
	op=(ALWAYS | NEXT | UNTIL | EVENTUALLY) '(' exp=Formula ')' //used to have parentheses 
;

//-----------------------------------------------------------------------------
terminal AND:
	('&' | '^')
;

terminal OR:
	('||' | 'V')
;

terminal NOT:
	('!' | '-')
;

terminal IMP:
	'->'
;

terminal LT:
	'<'
;

terminal LTE:
	'<='
;

terminal GT:
	'>'
;

terminal GTE:
	'>='
;

terminal EQ:
	'='
;

terminal NE:
	'!='
;

terminal NEXT:
	'X' | 'NEXT'
;

terminal ALWAYS:
	'G' | 'ALWAYS'
;

terminal UNTIL:
	'U' | 'UNTIL'
;

terminal EVENTUALLY:
	'F' | 'EVENTUALLY'
;

terminal FORALL:
	'forall' | 'A'
;

terminal EXISTS:
	'exists' | 'E'
;

terminal QUOTED_STRING	: 
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"'
;

