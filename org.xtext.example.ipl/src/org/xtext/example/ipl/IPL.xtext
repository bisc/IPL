grammar org.xtext.example.ipl.IPL with org.eclipse.xtext.common.Terminals

generate iPL "http://www.xtext.org/example/ipl/IPL"

import "http://aadl.info/AADL/2.0" as aadl2
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Spec:
	(imports += Import ';')*
	(decls += Declaration ';')*
	(formulas += Formula ';')*
;

Import:
	'import' importedNamespace=WQCREF
;

Declaration:
	TypedDec | FunDec
;

ViewDec:
	'use' 'view' ref=[aadl2::ComponentImplementation | CIREF] 'as' name=ID
;

ModelDec:
	'use' 'model' name=ID
;

BaseType:
	{TypeInt} 'int' | {TypeReal} 'real' | {TypeBool} 'bool' | {TypeElem} 'elem' //| 'string'
;

Type:
	BaseType | {TypeSet} '{' elem=BaseType '}'
;

TypedDec:
	VarDec | STVarDec | SortDec | ViewDec
;

VarDec:
	'var' name=ID ':' type = Type
;

STVarDec:
	'stvar' name=ID ':' type = Type
;

WQCREF:
	ID ('.' ID)* '.*'?
;

QCREF:
	ID ('::' ID)*;

CIREF:
	ID ('.' ID)?
;

ElemDec:
	'elem' ref=[aadl2::ComponentImplementation | CIREF]
;

SortDec:
	'set' name=ID ':' ref=[aadl2::ComponentImplementation | CIREF]
;

FunDec:
	(RFunDec | MFunDec | BFunDec)
;

RFunDec:
	'vrfun' name=ID '(' (paramTypes += Type)? (',' paramTypes += Type)* ')' IMP retType = Type
;

MFunDec:
	'mfun' name=ID '(' (paramTypes += Type)? (',' paramTypes += Type)* ')' IMP retType = Type
;

BFunDec:
	'bfun' name=ID '(' (paramTypes += Type)? (',' paramTypes += Type)* ')' IMP retType = Type
;

Bool:
	value=('true' | 'false')
;


Real returns EDouble:
	{EDouble} INT '.' INT (('e' | 'E') INT)?
;

Set:
	{Set} '{' (members += Expression)? (',' members += Expression)* '}'
;

Const:
	Set | ({Int} value=INT) | ({Real} value=Real ) | Bool //| {EString} STRING
;

Fun:
	name=[FunDec] '(' (args += Term)? (',' args += Term)* ')'
;

Prop returns Prop:
	{Prop} id=ID
;

Expression:
	Addition;

Addition returns Expression:
	Multiplication (({ExprOperation.left=current} op=('+' | '-')) right=Multiplication)*
;

Multiplication returns Expression:
	PropertyExpression (({ExprOperation.left=current} op=('*' | '/')) right=PropertyExpression)*
;

PropertyExpression returns Expression:
	//elem=Property '::' member=Ident
	PrimaryExpression (({PropertyExpression.left=current} '::') right=Prop)*
;


PrimaryExpression returns Expression:
	'(' Expression ')' |
	Const |
	Fun |
	{ID} id=ID
;

Term returns TermFormula: 
	'(' TermFormula ')' | (=> Expression)
;

TermFormula returns TermFormula:
		Term ({TermOperation.left=current} op=(LT | LTE | GT | GTE | EQ | NE) right=Term)*
;

TAtom:
	op=(ALWAYS | NEXT | UNTIL | EVENTUALLY) '(' exp=Formula ')'
;

QAtom:
	op=(FORALL | EXISTS) var=ID ':' set=PrimaryExpression ',' exp=Formula 
;

Formula:
	NegFormula ({FormulaOperation.left=current} op=(AND | OR | IMP) right=NegFormula)* | (-> QAtom)
;

NegFormula returns Formula:
	{Negation} NOT child=NegFormula | FormulaBase
;

FormulaBase returns Formula:
	(=> TermFormula) | '(' Formula ')' | TAtom | ModelExpr
;

ModelExpr:
	PrismExpr
;

//-----------------------------------------------------------------------------
// Prism specific stuff

PrismExpr:
	'$' (ProbQuery | RewardQuery) '$'
;

PrismComp:
	EQ | LT | GT
;

PrismValue:
	 Expression | {QM} '?'
;

ProbQuery:
	'P' comp=PrismComp value=PrismValue '[' expr=Formula ']' 
;

RewardQuery:
	'R' ('{"' rewardName=ID '"}')?  EQ value=PrismValue '[' expr=Formula ']'
;



//-----------------------------------------------------------------------------

terminal AND:
	('&' | '^')
;

terminal OR:
	('|' | 'V')
;

terminal NOT:
	('!' | '-')
;

terminal IMP:
	'->'
;

terminal LT:
	'<'
;

terminal LTE:
	'<='
;

terminal GT:
	'>'
;

terminal GTE:
	'>='
;

terminal EQ:
	'='
;

terminal NE:
	'!='
;

terminal NEXT:
	'X' | 'N' | 'NEXT'
;

terminal ALWAYS:
	'G' | 'ALWAYS'
;

terminal UNTIL:
	'U' | 'UNTIL'
;

terminal EVENTUALLY:
	'F' | 'EVENTUALLY'
;

terminal FORALL:
	'forall' | 'A'
;

terminal EXISTS:
	'exists' | 'E'
;


